using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;

/**
 * Survive the wrath of Kutulu
 * Coded fearlessly by JohnnyYuge & nmahoude (ok we might have been a bit scared by the old god...but don't say anything)
 **/
public class Point
{
	public int x;
	public int y;
	public Point() {}
	public Point(int x,int y)
	{
		this.x = x;
		this.y = y;
	}
	public void SetXY(int x, int y)
	{
	    this.x = x;
	    this.y = y;
	}
	public double Distance2 (Point p1)
	{
	    return (this.x-p1.x)*(this.x-p1.x) + (this.y-p1.y)*(this.y-p1.y);
	}
	public double Distance (Point p1)
	{
	    return Math.Pow((this.x-p1.x)*(this.x-p1.x) + (this.y-p1.y)*(this.y-p1.y),0.5);
	}
}	

public class Vector
{
    public double x;
    public double y;
    public void SetXY(double x, double y) {this.x=x;this.y=y;}
    public Vector (Point orig, Point dest) {this.x = dest.y-orig.x; this.y = dest.y-orig.y;}
    public Vector (double x, double y) {this.x=x;this.y=y;}
    public Vector () {this.x=0.0f;this.y=0.0f;}
    public double Norm2() {return x*x+y*y;}
    public double Norm() {return Math.Sqrt(Norm2());}
    public static Vector operator+ (Vector a,Vector b) 
    {
        Vector res = new Vector(a.x+b.x,a.y+b.y);
        return res;
    }
    public static Vector operator- (Vector a,Vector b) 
    {
        Vector res = new Vector(a.x-b.x,a.y-b.y);
        return res;
    }
    public static double Cross (Vector a,Vector b) 
    {
        return a.x*b.y-a.y*b.x;
    }
    public static double operator* (Vector a, Vector b)
    {
        return a.x*b.x + a.y*b.y;
    }
    public static Vector Rotation (Vector a, double b) // en degres
    {
        b *= Math.PI/180.0f;
        Vector res = new Vector(a.x*Math.Cos(b)+a.y*Math.Sin(b),-a.x*Math.Sin(b)+a.y*Math.Cos(b));
        return res;
    }
    public static Vector Rot_Affine(Vector point, Vector a, double b)
    {
        return (point + Rotation(a, b));
    }
    public static double Angle_Vec(Vector orig, Vector dest) // Renvoie le cos de l'angle de 2 vecteurs
    {
        return (orig*dest/orig.Norm()/dest.Norm());
    }
}

public enum Case 
{
    Mur, Vide, Portail
}

public class Plateau
{
    public string[] Tab;
    public int width;
    public int height;
    public Case[,] Mur;
    public double[,] Penal;
    public double[,] PenalJ;
    public double[,] PenalW;
    public double[,] PenalE;
    
    public Plateau (string[] Tab, int width, int height)
    {
        this.Tab = Tab;
        this.width = width;
        this.height = height;
        int lig=0; int col=0;
        this.Mur = new Case[height,width];
        this.Penal = new double[height,width];
        this.PenalJ = new double[height,width];
        this.PenalW = new double[height,width];
        this.PenalE = new double[height,width];
        Reset_Penal();
        foreach(string ligne in Tab)
        {
            foreach(char c in ligne)
            {
                if (c=='#') Mur[lig,col]=Case.Mur;
                else if (c=='.') Mur[lig,col]=Case.Vide;
                else Mur[lig,col]=Case.Portail;
                col++;
            }
            lig++;
            col=0;
        }
    }
    
    public void Reset_Penal()
    {
        for (int i=0;i<height;i++)
            for(int j=0;j<width;j++)
            {
                Penal[i,j] = 0.0;
                PenalJ[i,j] = 0.0;
                PenalW[i,j] = 0.0;
                PenalE[i,j] = 0.0;
            }
    }
    
}

public class Entite{
	public int x;
	public int y;
	public Point pos;
	public int Id;
	public double Dist_To_Hero;
	public Entite (Point p, int Id)
	{
		this.x 		= p.x;
		this.y		= p.y;
		this.Id     = Id;
		this.pos    = p;
	}
}

public class Joueur:Entite
{
	public int sante;
	public Joueur (Point p_j, int sante, int Id, double Dist_To_Hero) : base(p_j, Id)
	{
		this.sante 	= sante;
		this.Dist_To_Hero = Dist_To_Hero;
	}
}

public class Hero:Entite
{
	public int sante;
	public Hero(Point p_h, int sante, int Id) : base(p_h, Id)
	{
		this.sante 	= sante;
	}
}

public class Wanderer:Entite
{
    public bool isWandering;
    public int cible;
    public int temps;
    public Wanderer(Point p_w, bool isWandering, int temps, int Id, int cible, double Dist_To_Hero) : base(p_w, Id)
    {
        this.isWandering = isWandering;
        this.temps = temps;
        this.cible = cible;
		this.Dist_To_Hero = Dist_To_Hero;
    }
}

public class Joueur_Controller{
	public Hero hero;
	public List<Joueur> joueurs;
	public List<Wanderer> wanderers;
	public int Nb_joueurs = 3;
	public int sanityLossLonely;
	public int sanityLossGroup;
	public int wandererSpawnTime;
	public int wandererLifeTime;
	
	public Joueur_Controller(int sanityLossLonely, int sanityLossGroup, 
	                         int wandererSpawnTime, int wandererLifeTime)
	{
		hero = null;
		joueurs = new List<Joueur>();
	    wanderers = new List<Wanderer>();
		this.sanityLossLonely = sanityLossLonely;
		this.sanityLossGroup = sanityLossGroup;
		this.wandererSpawnTime = wandererSpawnTime;
		this.wandererLifeTime = wandererLifeTime;
	   
	}
	
	public double Compute_Dist(Plateau plateau, Point p, Point p_H)
	{
		double resultat = 0.0;
		// Calcul de la distance murs entre entité et Hero
		return resultat;
	}
	
	public void Update(Point pos_Hero, int sante_Hero, int Id_Hero,
	                List<Point> pos_Joueurs, List<int> sante_Joueurs, List<int> id_J,
					List<int> id_Wanderer, List<Point> pos_Wanderer, List<bool> is_Wandering,
					List<int> temps_Wanderer, List<int> cible_Wandering, Plateau plateau)
	{
		
		// Update du hero
		if (hero == null)
    		hero = new Hero(pos_Hero, sante_Hero, Id_Hero);
		hero.Update(pos_Hero, sante_Hero);
		
		// Update des joueurs
		joueurs.Clear();
		for (int i=0;i<id_J.Count();i++)
		    joueurs.Add(new Joueur(pos_Joueurs[i],sante_Joueurs[i], id_J[i]), Compute_Dist(plateau, pos_Joueurs[i], pos_Hero));

	    // Update des wanderers
	    wanderers.Clear();
	    for (int i=0;i<id_Wanderer.Count();i++)
	        wanderers.Add(new Wanderer(pos_Wanderer[i],is_Wandering[i],temps_Wanderer[i],
	                            id_Wanderer[i],cible_Wandering[i], Compute_Dist(plateau, pos_Joueurs[i], pos_Hero)));
	}
}

public class IA
{
    public enum Strategie {Penalisation, RL}
    public Strategie strategie;
    public Joueur_Controller joueur_C;
    public Plateau plateau;
	public PENALISE Set_Penalise;
    public IA()
    {
        this.strategie = Strategie.Penalisation;
		Set_Penalise = PARAMS.Set_Normal;
    }
	
    public void Update_Strategie()
	{
		// Calcul strategie
		strategie = Strategie.Penalisation;
		
		// Mise à jour des parametres
		switch (strategie)
		{
			case Strategie.Penalisation:
				Set_Penalise = PARAMS.Set_Normal;
				break;
		}
	}
	
    public string Analyse (Joueur_Controller joueur_C, Plateau plateau)
    {
        string resultat = "";
        this.joueur_C = joueur_C;
        this.plateau = plateau;
        // Analyse
        Update_Strategie();
		
        if (strategie == Strategie.Penalisation)
        {
            double VarJ = Set_Penalise.VarJ;
            double VarW = Set_Penalise.VarW;
            double VarM = Set_Penalise.VarM;
            double penal;
            int x_h = joueur_C.hero.x;
            int y_h = joueur_C.hero.y;
            double h2 = Convert.ToDouble(plateau.height*plateau.height);
            double w2 = Convert.ToDouble(plateau.width*plateau.width);
            double min = 100.0f;
			double Act_J = Set_Penalise.Act_J;
			double Act_W = Set_Penalise.Act_W;
			double Act_E = Set_Penalise.Act_E;
			
			// Mise à zero des penalités
            plateau.Reset_Penal();
			
            // Construction des pénalisations
            for (int i=0;i<plateau.height;i++)
                for (int j=0;j<plateau.width;j++) {
                    penal = 0.0f;
                    // Influence des joueurs (benefique)
                    foreach (Joueur jj in joueur_C.joueurs)
                    {
                        plateau.PenalJ[i,j]+= joueur_C.joueurs.Min(n=>n.pos.Distance(new Point(j,i))*VarJ);//jj.pos.Distance(new Point(j,i))*VarJ;
                    }
                    // Influence des minions (malefiques)
                    foreach (Wanderer w in joueur_C.wanderers)
                    {
                        plateau.PenalW[i,j]+= joueur_C.wanderers.Max(n=>n.pos.Distance(new Point(j,i))*VarW);
                    }
                    // Influence de l'environnement (murs)
                    plateau.PenalE[i,j]+= VarM*(Convert.ToDouble((2*i-plateau.height)* (2*i-plateau.height))/h2+
                    Convert.ToDouble((2*j-plateau.width)* (2*j-plateau.width))/w2);
                    
                    plateau.Penal[i,j] = Act_J * plateau.PenalJ[i,j] +
										 Act_W * plateau.PenalW[i,j] +
										 Act_E * plateau.PenalE[i,j];
                }
            
			// Print des tableaux de pénalité
			Print_Penalite(plateau, x_h, y_h);
			
			// Selection du min du tableau de pénalisations si case vide
			resultat = Choix_Deplacement(plateau, x_h, y_h);			
        }      
        return resultat;
    }
	
	string Choix_Deplacement(Plateau plateau, int x_h, int y_h)
	{
		int x_res = 0;
		int y_res = 0;
		string resultat;
		// Choix de la meilleure possibilite
		if (plateau.Mur[y_h,x_h-1] == Case.Vide)
		{// A Gauche
			min =plateau.Penal[y_h,x_h-1];
			x_res = x_h -1;
			y_res = y_h;
		}
		if ((plateau.Mur[y_h,x_h+1] == Case.Vide) & plateau.Penal[y_h,x_h+1]<min)
		{// A Droite
			min = plateau.Penal[y_h,x_h+1];
			x_res = x_h +1;
			y_res = y_h;
		}
		if ((plateau.Mur[y_h-1,x_h] == Case.Vide) & plateau.Penal[y_h-1,x_h]<min)
		{// En haut
			min = plateau.Penal[y_h-1,x_h];
			x_res = x_h;
			y_res = y_h - 1;
		}
		if ((plateau.Mur[y_h+1,x_h] == Case.Vide) & plateau.Penal[y_h+1,x_h]<min)
		{// En Bas
			min = plateau.Penal[y_h+1,x_h];
			x_res = x_h;
			y_res = y_h + 1;
		}
		resultat += "MOVE " + x_res.ToString() + " " + y_res.ToString();
	}
	
	void Print_Penalite(Plateau plateau, int x_h, int y_h)
	{
        double resol = 1000.0;
        string res = "";
        for (int i=Convert.ToInt32(Math.Max(0,y_h-5));i<Convert.ToInt32(Math.Min(plateau.height,y_h+5));i++)
        {
            for (int j=Convert.ToInt32(Math.Max(0,x_h-5));j<Convert.ToInt32(Math.Min(plateau.width,x_h+5));j++)
                res += (Convert.ToSingle(Convert.ToInt32(plateau.Penal[i,j]*resol))/resol).ToString() + " ";
            res +="\n";
        }
        Console.Error.WriteLine("X= " +x_h+" Y= " + y_h+"\n" +res);
        string resJ = "";
        for (int i=Convert.ToInt32(Math.Max(0,y_h-5));i<Convert.ToInt32(Math.Min(plateau.height,y_h+5));i++)
        {
			for (int j=Convert.ToInt32(Math.Max(0,x_h-5));j<Convert.ToInt32(Math.Min(plateau.width,x_h+5));j++)
				resJ += (Convert.ToSingle(Convert.ToInt32(plateau.PenalJ[i,j]*resol)/resol)).ToString() + " ";
			resJ +="\n";
		}
		Console.Error.WriteLine("JOEURS \n" +resJ);
		string resW = "";
		for (int i=Convert.ToInt32(Math.Max(0,y_h-5));i<Convert.ToInt32(Math.Min(plateau.height,y_h+5));i++)
		{
			for (int j=Convert.ToInt32(Math.Max(0,x_h-5));j<Convert.ToInt32(Math.Min(plateau.width,x_h+5));j++)
				resW += (Convert.ToSingle(Convert.ToInt32(plateau.PenalW[i,j]*resol)/resol)).ToString() + " ";
			resW +="\n";
		}
		Console.Error.WriteLine("WANDERERS \n"+resW);
		string resE = "";
		for (int i=Convert.ToInt32(Math.Max(0,y_h-5));i<Convert.ToInt32(Math.Min(plateau.height,y_h+5));i++)
		{
			for (int j=Convert.ToInt32(Math.Max(0,x_h-5));j<Convert.ToInt32(Math.Min(plateau.width,x_h+5));j++)
				resE += (Convert.ToSingle(Convert.ToInt32(plateau.PenalE[i,j]*resol)/resol)).ToString() + " ";
			resE +="\n";
		}
		Console.Error.WriteLine("ENVIRONNEMENT\n" +resE);
	}
}

public class Jeu
{
	public Plateau plateau;
	public Joueur_Controller joueur_Controller;
	public IA iA;
	public Jeu(string[] Tab, int width, int height, int sanityLossLonely,
		                int sanityLossGroup, int wandererSpawnTime, int wandererLifeTime)
	{
		plateau             = new Plateau(Tab, width, height);
		joueur_Controller   = new Joueur_Controller(sanityLossLonely,
		                                            sanityLossGroup,
		                                            wandererSpawnTime,
		                                            wandererLifeTime);
		iA = new IA();
	}
	
	public void Update(Point pos_Hero, int sante_Hero,int id_Hero,
	                List<Point> pos_Joueurs, List<int> sante_Joueurs, List<int> id_J,
					List<int> id_Wanderer, List<Point> pos_Wanderer, List<bool> is_Wandering, List<int> temps_Wanderer, List<int> cible_Wandering)
	{
		joueur_Controller.Update(pos_Hero, sante_Hero, id_Hero,
	                pos_Joueurs, sante_Joueurs, id_J,
					id_Wanderer,pos_Wanderer, is_Wandering, temps_Wanderer, cible_Wandering, plateau);
	}
	
	public string Commande()
	{
		string resultat = iA.Analyse(joueur_Controller, plateau);
		return resultat;
	}
}
public static class PARAMS
{
	public struct PENALISE
	{
		static double VarJ;
		static double VarW;
		static double VarM;
		static double Active_Penalisation_Joueurs;
		static double Active_Penalisation_Wanderers;
		static double Active_Penalisation_Env;
		
		public PENALISE (double VarJ, double VarW, double VarM, double Act_J, double Act_W, double Act_E)
		{
			this.VarJ = VarJ;
			this.VarM = VarM;
			this.VarW = VarW;
			this.Active_Penalisation_Joueurs = Act_J;
			this.Active_Penalisation_Wanderers = Act_W;
			this.Active_Penalisation_Env = Act_E;
		}
	}
	
	static PENALISE Set_Normal = new PENALISE (1.0/16.0, // VarJ
												1.0/4.0, // VarM
												-1.0/4.0,  // VarW
												1.0, // Active Penalisation Joueur
												1.0, // Active_Penalisation_Wanderers
												0.0); // Active_Penalisation_Env
}

class Player
{
    static void Main(string[] args)
    {
        string[] inputs;
        int width = int.Parse(Console.ReadLine());
        int height = int.Parse(Console.ReadLine());
        
        // Infos hero
        int id_Hero = -1;
		int sante_Hero = -1;
		Point pos_Hero = new Point();

        // Infos joueurs
        List<int> id_Joueurs = new List<int>();
        List<int> sante_Joueurs = new List<int>();
        List<Point> pos_Joueurs = new List<Point>();
        
        // Infos Wanderer
        List<Point> pos_Wanderer = new List<Point>();
        List<int> id_Wanderer = new List<int>();
        List<int> temps_Wanderer = new List<int>();
        List<bool> is_Wandering= new List<bool>();
        List<int> cible_Wandering = new List<int>();
        
        string[] line = new string[height];
		Jeu jeu;
        for (int i = 0; i < height; i++)
        {
            line[i] = Console.ReadLine();
        }
        inputs = Console.ReadLine().Split(' ');
        int sanityLossLonely = int.Parse(inputs[0]); // how much sanity you lose every turn when alone, always 3 until wood 1
        int sanityLossGroup = int.Parse(inputs[1]); // how much sanity you lose every turn when near another player, always 1 until wood 1
        int wandererSpawnTime = int.Parse(inputs[2]); // how many turns the wanderer take to spawn, always 3 until wood 1
        int wandererLifeTime = int.Parse(inputs[3]); // how many turns the wanderer is on map after spawning, always 40 until wood 1

		jeu = new Jeu(line, width, height,
		                sanityLossLonely,
		                sanityLossGroup,
		                wandererSpawnTime,
		                wandererLifeTime);
        
        // game loop
        while (true)
        {
            // Clear des listes
            pos_Wanderer.Clear();
            id_Wanderer.Clear();
            temps_Wanderer.Clear();
            is_Wandering.Clear();
            cible_Wandering.Clear();
            id_Joueurs.Clear();
            sante_Joueurs.Clear();
            pos_Joueurs.Clear();
            
            int entityCount = int.Parse(Console.ReadLine()); // the first given entity corresponds to your explorer
            for (int i = 0; i < entityCount; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                string entityType = inputs[0];
                int id = int.Parse(inputs[1]);
                int x = int.Parse(inputs[2]);
                int y = int.Parse(inputs[3]);
                int param0 = int.Parse(inputs[4]);
                int param1 = int.Parse(inputs[5]);
                int param2 = int.Parse(inputs[6]);
                if (i==0)
                {
                    pos_Hero.SetXY(x,y);
                    sante_Hero  = param0;
                    id_Hero     = id;
                }
                else if (entityType=="EXPLORER") // Cas explorer
                {
                    pos_Joueurs.Add(new Point(x,y));
                    sante_Joueurs.Add(param0);
                    id_Joueurs.Add(id);
                }
                else // Cas wanderer
                {
                    id_Wanderer.Add(id);
                    pos_Wanderer.Add(new Point(x,y));
                    is_Wandering.Add(param1==1);
                    temps_Wanderer.Add(param0);
                    cible_Wandering.Add(param2);
                }
            }

			jeu.Update(pos_Hero, sante_Hero, id_Hero,pos_Joueurs,sante_Joueurs, id_Joueurs, 
				id_Wanderer, pos_Wanderer, is_Wandering, temps_Wanderer, cible_Wandering);

            Console.WriteLine(jeu.Commande());
        }
    }
}